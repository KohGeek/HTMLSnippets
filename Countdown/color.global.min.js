var Color = function () { "use strict"; function e(e, t) { let r = e.length; Array.isArray(e[0]) || (e = [e]), Array.isArray(t[0]) || (t = t.map((e => [e]))); let a = t[0].length, o = t[0].map(((e, r) => t.map((e => e[r])))), n = e.map((e => o.map((t => { let r = 0; if (!Array.isArray(e)) { for (let a of t) r += e * a; return r } for (let a = 0; a < e.length; a++)r += e[a] * (t[a] || 0); return r })))); return 1 === r && (n = n[0]), 1 === a ? n.map((e => e[0])) : n } function t(e) { return "string" === r(e) } function r(e) { return (Object.prototype.toString.call(e).match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase() } function a(e, t) { e = +e, t = +t; let r = (Math.floor(e) + "").length; if (t > r) return +e.toFixed(t - r); { let a = 10 ** (r - t); return Math.round(e / a) * a } } function o(e) { if (!e) return; e = e.trim(); const t = /^-?[\d.]+$/; let r = e.match(/^([a-z]+)\((.+?)\)$/i); if (r) { let e = []; return r[2].replace(/\/?\s*([-\w.]+(?:%|deg)?)/g, ((r, a) => { /%$/.test(a) ? (a = new Number(a.slice(0, -1) / 100)).type = "<percentage>" : /deg$/.test(a) ? ((a = new Number(+a.slice(0, -3))).type = "<angle>", a.unit = "deg") : t.test(a) && ((a = new Number(a)).type = "<number>"), r.startsWith("/") && ((a = a instanceof Number ? a : new Number(a)).alpha = !0), e.push(a) })), { name: r[1].toLowerCase(), rawName: r[1], rawArgs: r[2], args: e } } } function n(e) { return e[e.length - 1] } function s(e, t, r) { return isNaN(e) ? t : isNaN(t) ? e : e + (t - e) * r } function i(e, t, r) { return (r - e) / (t - e) } function l(e, t, r) { return s(t[0], t[1], i(e[0], e[1], r)) } function c(e) { return e.map((e => e.split("|").map((e => { let t = (e = e.trim()).match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/); if (t) { let e = new String(t[1]); return e.range = [+t[2], +t[3]], e } return e })))) } var u = Object.freeze({ __proto__: null, interpolate: s, interpolateInv: i, isString: t, last: n, mapRange: l, multiplyMatrices: e, parseCoordGrammar: c, parseFunction: o, toPrecision: a, type: r }); const h = new class { add(e, t, r) { if ("string" == typeof arguments[0]) (Array.isArray(e) ? e : [e]).forEach((function (e) { this[e] = this[e] || [], t && this[e][r ? "unshift" : "push"](t) }), this); else for (var e in arguments[0]) this.add(e, arguments[0][e], arguments[1]) } run(e, t) { this[e] = this[e] || [], this[e].forEach((function (e) { e.call(t && t.context ? t.context : t, t) })) } }; var m = { gamut_mapping: "lch.c", precision: 5, deltaE: "76" }; const d = { D50: [.3457 / .3585, 1, .2958 / .3585], D65: [.3127 / .329, 1, .3583 / .329] }; function p(e) { return Array.isArray(e) ? e : d[e] } function f(t, r, a, o = {}) { if (t = p(t), r = p(r), !t || !r) throw new TypeError(`Missing white point to convert ${t ? "" : "from"}${t || r ? "" : "/"}${r ? "" : "to"}`); if (t === r) return a; let n = { W1: t, W2: r, XYZ: a, options: o }; if (h.run("chromatic-adaptation-start", n), n.M || (n.W1 === d.D65 && n.W2 === d.D50 ? n.M = [[1.0479298208405488, .022946793341019088, -.05019222954313557], [.029627815688159344, .990434484573249, -.01707382502938514], [-.009243058152591178, .015055144896577895, .7518742899580008]] : n.W1 === d.D50 && n.W2 === d.D65 && (n.M = [[.9554734527042182, -.023098536874261423, .0632593086610217], [-.028369706963208136, 1.0099954580058226, .021041398966943008], [.012314001688319899, -.020507696433477912, 1.3303659366080753]])), h.run("chromatic-adaptation-end", n), n.M) return e(n.M, n.XYZ); throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.") } class g { constructor(e) { this.id = e.id, this.name = e.name, this.base = e.base ? g.get(e.base) : null, this.aliases = e.aliases, this.base && (this.fromBase = e.fromBase, this.toBase = e.toBase); let t = e.coords ?? this.base.coords; for (let e in t) "name" in t[e] || (t[e].name = e); this.coords = t; let r = e.white ?? this.base.white ?? "D65"; this.white = p(r), this.formats = e.formats ?? {}; for (let e in this.formats) { let t = this.formats[e]; t.type ||= "function", t.name ||= e } e.cssId && !this.formats.functions?.color ? (this.formats.color = { id: e.cssId }, Object.defineProperty(this, "cssId", { value: e.cssId })) : this.formats?.color && !this.formats?.color.id && (this.formats.color.id = this.id), this.referred = e.referred, Object.defineProperty(this, "path", { value: b(this).reverse(), writable: !1, enumerable: !0, configurable: !0 }), h.run("colorspace-init-end", this) } inGamut(e, { epsilon: t = 75e-6 } = {}) { if (this.isPolar) return e = this.toBase(e), this.base.inGamut(e, { epsilon: t }); let r = Object.values(this.coords); return e.every(((e, a) => { let o = r[a]; if ("angle" !== o.type && o.range) { if (Number.isNaN(e)) return !0; let [r, a] = o.range; return (void 0 === r || e >= r - t) && (void 0 === a || e <= a + t) } return !0 })) } get cssId() { return this.formats.functions?.color?.id || this.id } get isPolar() { for (let e in this.coords) if ("angle" === this.coords[e].type) return !0; return !1 } getFormat(e) { if ("object" == typeof e) return e = M(e, this); let t; return t = "default" === e ? Object.values(this.formats)[0] : this.formats[e], t ? (t = M(t, this), t) : null } equals(e) { return !!e && (this === e || this.id === e.id) } to(e, t) { if (1 === arguments.length && ([e, t] = [e.space, e.coords]), e = g.get(e), this.equals(e)) return t; t = t.map((e => Number.isNaN(e) ? 0 : e)); let r, a, o = this.path, n = e.path; for (let e = 0; e < o.length && o[e].equals(n[e]); e++)r = o[e], a = e; if (!r) throw new Error(`Cannot convert between color spaces ${this} and ${e}: no connection space was found`); for (let e = o.length - 1; e > a; e--)t = o[e].toBase(t); for (let e = a + 1; e < n.length; e++)t = n[e].fromBase(t); return t } from(e, t) { return 1 === arguments.length && ([e, t] = [e.space, e.coords]), (e = g.get(e)).to(this, t) } toString() { return `${this.name} (${this.id})` } getMinCoords() { let e = []; for (let t in this.coords) { let r = this.coords[t], a = r.range || r.refRange; e.push(a?.min ?? 0) } return e } static registry = {}; static get all() { return [...new Set(Object.values(g.registry))] } static register(e, t) { if (1 === arguments.length && (e = (t = arguments[0]).id), t = this.get(t), this.registry[e] && this.registry[e] !== t) throw new Error(`Duplicate color space registration: '${e}'`); if (this.registry[e] = t, 1 === arguments.length && t.aliases) for (let e of t.aliases) this.register(e, t); return t } static get(e, ...t) { if (!e || e instanceof g) return e; if ("string" === r(e)) { let t = g.registry[e.toLowerCase()]; if (!t) throw new TypeError(`No color space found with id = "${e}"`); return t } if (t.length) return g.get(...t); throw new TypeError(`${e} is not a valid color space`) } static resolveCoord(e, t) { let a, o, n = r(e); if ("string" === n ? e.includes(".") ? [a, o] = e.split(".") : [a, o] = [, e] : Array.isArray(e) ? [a, o] = e : (a = e.space, o = e.coordId), a = g.get(a), a || (a = t), !a) throw new TypeError(`Cannot resolve coordinate reference ${e}: No color space specified and relative references are not allowed here`); if (n = r(o), "number" === n || "string" === n && o >= 0) { let e = Object.entries(a.coords)[o]; if (e) return { space: a, id: e[0], index: o, ...e[1] } } a = g.get(a); let s = o.toLowerCase(), i = 0; for (let e in a.coords) { let t = a.coords[e]; if (e.toLowerCase() === s || t.name?.toLowerCase() === s) return { space: a, id: e, index: i, ...t }; i++ } throw new TypeError(`No "${o}" coordinate found in ${a.name}. Its coordinates are: ${Object.keys(a.coords).join(", ")}`) } static DEFAULT_FORMAT = { type: "functions", name: "color" } } function b(e) { let t = [e]; for (let r = e; r = r.base;)t.push(r); return t } function M(e, { coords: t } = {}) { if (e.coords && !e.coordGrammar) { e.type ||= "function", e.name ||= "color", e.coordGrammar = c(e.coords); let r = Object.entries(t).map((([t, r], a) => { let o = e.coordGrammar[a][0], n = r.range || r.refRange, s = o.range, i = ""; return "<percentage>" == o ? (s = [0, 100], i = "%") : "<angle>" == o && (i = "deg"), { fromRange: n, toRange: s, suffix: i } })); e.serializeCoords = (e, t) => e.map(((e, o) => { let { fromRange: n, toRange: s, suffix: i } = r[o]; return n && s && (e = l(n, s, e)), e = a(e, t), i && (e += i), e })) } return e } var w = new g({ id: "xyz-d65", name: "XYZ D65", coords: { x: { name: "X" }, y: { name: "Y" }, z: { name: "Z" } }, white: "D65", formats: { color: { ids: ["xyz-d65", "xyz"] } }, aliases: ["xyz"] }); class y extends g { constructor(t) { t.coords || (t.coords = { r: { range: [0, 1], name: "Red" }, g: { range: [0, 1], name: "Green" }, b: { range: [0, 1], name: "Blue" } }), t.base || (t.base = w), t.toXYZ_M && t.fromXYZ_M && (t.toBase ??= r => { let a = e(t.toXYZ_M, r); return this.white !== this.base.white && (a = f(this.white, this.base.white, a)), a }, t.fromBase ??= r => (r = f(this.base.white, this.white, r), e(t.fromXYZ_M, r))), t.referred ??= "display", super(t) } } function C(e, { meta: t } = {}) { let r = { str: String(e)?.trim() }; if (h.run("parse-start", r), r.color) return r.color; if (r.parsed = o(r.str), r.parsed) { let e = r.parsed.name; if ("color" === e) { let e = r.parsed.args.shift(), a = r.parsed.rawArgs.indexOf("/") > 0 ? r.parsed.args.pop() : 1; for (let o of g.all) { let n = o.getFormat("color"); if (n && (e === n.id || n.ids?.includes(e))) { const e = Object.keys(o.coords).map(((e, t) => r.parsed.args[t] || 0)); return t && (t.formatId = "color"), { spaceId: o.id, coords: e, alpha: a } } } let o = ""; if (e in g.registry) { let t = g.registry[e].formats?.functions?.color?.id; t && (o = `Did you mean color(${t})?`) } throw new TypeError(`Cannot parse color(${e}). ` + (o || "Missing a plugin?")) } for (let a of g.all) { let o = a.getFormat(e); if (o && "function" === o.type) { let s = 1; (o.lastAlpha || n(r.parsed.args).alpha) && (s = r.parsed.args.pop()); let i, c = r.parsed.args; return o.coordGrammar && (i = Object.entries(a.coords).map((([t, r], a) => { let n = o.coordGrammar[a], s = c[a]?.type, i = n.find((e => e == s)); if (!i) { let a = r.name || t; throw new TypeError(`${s} not allowed for ${a} in ${e}()`) } let u = i.range; "<percentage>" === s && (u ||= [0, 1]); let h = r.range || r.refRange; return u && h && (c[a] = l(u, h, c[a])), i }))), t && Object.assign(t, { formatId: o.name, types: i }), { spaceId: a.id, coords: c, alpha: s } } } } else for (let e of g.all) for (let a in e.formats) { let o = e.formats[a]; if ("custom" !== o.type) continue; if (o.test && !o.test(r.str)) continue; let n = o.parse(r.str); if (n) return n.alpha ??= 1, t && (t.formatId = a), n } throw new TypeError(`Could not parse ${e} as a color. Missing a plugin?`) } function _(e) { if (!e) throw new TypeError("Empty color reference"); t(e) && (e = C(e)); let r = e.space || e.spaceId; return r instanceof g || (e.space = g.get(r)), void 0 === e.alpha && (e.alpha = 1), e } function v(e, t) { return (t = g.get(t)).from(e) } function B(e, t) { let { space: r, index: a } = g.resolveCoord(t, e.space); return v(e, r)[a] } function R(e, t, r) { return t = g.get(t), e.coords = t.to(e.space, r), e } function k(e, t, a) { if (e = _(e), 2 === arguments.length && "object" === r(arguments[1])) { let t = arguments[1]; for (let r in t) k(e, r, t[r]) } else { "function" == typeof a && (a = a(B(e, t))); let { space: r, index: o } = g.resolveCoord(t, e.space), n = v(e, r); n[o] = a, R(e, r, n) } return e } var x = new g({ id: "xyz-d50", name: "XYZ D50", white: "D50", base: w, fromBase: e => f(w.white, "D50", e), toBase: e => f("D50", w.white, e), formats: { color: {} } }); const A = 24 / 116, N = 24389 / 27; let z = d.D50; var E = new g({ id: "lab", name: "Lab", coords: { l: { refRange: [0, 100], name: "L" }, a: { refRange: [-125, 125] }, b: { refRange: [-125, 125] } }, white: z, base: x, fromBase(e) { let t = e.map(((e, t) => e / z[t])).map((e => e > .008856451679035631 ? Math.cbrt(e) : (N * e + 16) / 116)); return [116 * t[1] - 16, 500 * (t[0] - t[1]), 200 * (t[1] - t[2])] }, toBase(e) { let t = []; return t[1] = (e[0] + 16) / 116, t[0] = e[1] / 500 + t[1], t[2] = t[1] - e[2] / 200, [t[0] > A ? Math.pow(t[0], 3) : (116 * t[0] - 16) / N, e[0] > 8 ? Math.pow((e[0] + 16) / 116, 3) : e[0] / N, t[2] > A ? Math.pow(t[2], 3) : (116 * t[2] - 16) / N].map(((e, t) => e * z[t])) }, formats: { lab: { coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"] } } }); function j(e) { return (e % 360 + 360) % 360 } var P = new g({ id: "lch", name: "LCH", coords: { l: { refRange: [0, 100], name: "Lightness" }, c: { refRange: [0, 150], name: "Chroma" }, h: { refRange: [0, 360], type: "angle", name: "Hue" } }, base: E, fromBase(e) { let t, [r, a, o] = e; return t = Math.abs(a) < .02 && Math.abs(o) < .02 ? NaN : 180 * Math.atan2(o, a) / Math.PI, [r, Math.sqrt(a ** 2 + o ** 2), j(t)] }, toBase(e) { let [t, r, a] = e; return r < 0 && (r = 0), isNaN(a) && (a = 0), [t, r * Math.cos(a * Math.PI / 180), r * Math.sin(a * Math.PI / 180)] }, formats: { lch: { coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"] } } }); const L = 25 ** 7, O = Math.PI, S = 180 / O, $ = O / 180; function D(e, t, { kL: r = 1, kC: a = 1, kH: o = 1 } = {}) { let [n, s, i] = E.from(e), l = P.from(E, [n, s, i])[1], [c, u, h] = E.from(t), m = P.from(E, [c, u, h])[1]; l < 0 && (l = 0), m < 0 && (m = 0); let d = ((l + m) / 2) ** 7, p = .5 * (1 - Math.sqrt(d / (d + L))), f = (1 + p) * s, g = (1 + p) * u, b = Math.sqrt(f ** 2 + i ** 2), M = Math.sqrt(g ** 2 + h ** 2), w = 0 === f && 0 === i ? 0 : Math.atan2(i, f), y = 0 === g && 0 === h ? 0 : Math.atan2(h, g); w < 0 && (w += 2 * O), y < 0 && (y += 2 * O), w *= S, y *= S; let C, _ = c - n, v = M - b, B = y - w, R = w + y, k = Math.abs(B); b * M == 0 ? C = 0 : k <= 180 ? C = B : B > 180 ? C = B - 360 : B < -180 ? C = B + 360 : console.log("the unthinkable has happened"); let x, A = 2 * Math.sqrt(M * b) * Math.sin(C * $ / 2), N = (n + c) / 2, z = (b + M) / 2, j = Math.pow(z, 7); x = b * M == 0 ? R : k <= 180 ? R / 2 : R < 360 ? (R + 360) / 2 : (R - 360) / 2; let D = (N - 50) ** 2, I = 1 + .015 * D / Math.sqrt(20 + D), q = 1 + .045 * z, G = 1; G -= .17 * Math.cos((x - 30) * $), G += .24 * Math.cos(2 * x * $), G += .32 * Math.cos((3 * x + 6) * $), G -= .2 * Math.cos((4 * x - 63) * $); let T = 1 + .015 * z * G, X = 30 * Math.exp(-1 * ((x - 275) / 25) ** 2), Y = 2 * Math.sqrt(j / (j + L)), Z = (_ / (r * I)) ** 2; return Z += (v / (a * q)) ** 2, Z += (A / (o * T)) ** 2, Z += -1 * Math.sin(2 * X * $) * Y * (v / (a * q)) * (A / (o * T)), Math.sqrt(Z) } const I = 75e-6; function q(e, t = e.space, { epsilon: r = I } = {}) { e = _(e), t = g.get(t); let a = e.coords; return t !== e.space && (a = t.from(e)), t.inGamut(a, { epsilon: r }) } function G(e) { return { space: e.space, coords: e.coords.slice(), alpha: e.alpha } } function T(e, { method: r = m.gamut_mapping, space: a = e.space } = {}) { if (t(arguments[1]) && (a = arguments[1]), q(e, a = g.get(a), { epsilon: 0 })) return _(e); let o = X(e, a); if ("clip" !== r && !q(e, a)) { let t = T(G(o), { method: "clip", space: a }); if (D(e, t) > 2) { let e = g.resolveCoord(r), t = e.space, n = e.id, s = X(o, t), i = .01, l = (e.range || e.refRange)[0], c = B(s, n); for (; c - l > i;) { let e = G(s); e = T(e, { space: a, method: "clip" }), D(s, e) - 2 < i ? l = B(s, n) : c = B(s, n), k(s, n, (l + c) / 2) } o = X(s, a) } else o = t } if ("clip" === r || !q(o, a, { epsilon: 0 })) { let e = Object.values(a.coords).map((e => e.range || [])); o.coords = o.coords.map(((t, r) => { let [a, o] = e[r]; return void 0 !== a && (t = Math.max(a, t)), void 0 !== o && (t = Math.min(t, o)), t })) } return a !== e.space && (o = X(o, e.space)), e.coords = o.coords, e } function X(e, t, { inGamut: r } = {}) { e = _(e); let a = (t = g.get(t)).from(e), o = { space: t, coords: a, alpha: e.alpha }; return r && (o = T(o)), o } function Y(e, { precision: t = m.precision, format: r = "default", inGamut: o = !0, ...n } = {}) { let s, i = r; r = (e = _(e)).space.getFormat(r) ?? e.space.getFormat("default") ?? g.DEFAULT_FORMAT, o ||= r.toGamut; let l = e.coords; if (l = l.map((e => e || 0)), o && !q(e) && (l = T(G(e), !0 === o ? void 0 : o).coords), "custom" === r.type) { if (n.precision = t, !r.serialize) throw new TypeError(`format ${i} can only be used to parse colors, not for serialization`); s = r.serialize(l, e.alpha, n) } else { let o = r.name || "color"; r.serializeCoords ? l = r.serializeCoords(l, t) : null !== t && (l = l.map((e => a(e, t)))); let n = [...l]; if ("color" === o) { let t = r.id || r.ids?.[0] || e.space.id; n.unshift(t) } let i = e.alpha; null !== t && (i = a(i, t)); let c = e.alpha < 1 && !r.noAlpha ? `${r.commas ? "," : " /"} ${i}` : ""; s = `${o}(${n.join(r.commas ? ", " : " ")}${c})` } return s } T.returns = "color", X.returns = "color"; var Z = new y({ id: "rec2020-linear", name: "Linear REC.2020", white: "D65", toXYZ_M: [[.6369580483012914, .14461690358620832, .1688809751641721], [.2627002120112671, .6779980715188708, .05930171646986196], [0, .028072693049087428, 1.060985057710791]], fromXYZ_M: [[1.716651187971268, -.355670783776392, -.25336628137366], [-.666684351832489, 1.616481236634939, .0157685458139111], [.017639857445311, -.042770613257809, .942103121235474]], formats: { color: {} } }); const F = 1.09929682680944, H = .018053968510807; var W = new y({ id: "rec2020", name: "REC.2020", base: Z, toBase: e => e.map((function (e) { return e < 4.5 * H ? e / 4.5 : Math.pow((e + F - 1) / F, 1 / .45) })), fromBase: e => e.map((function (e) { return e >= H ? F * Math.pow(e, .45) - (F - 1) : 4.5 * e })), formats: { color: {} } }); var J = new y({ id: "p3-linear", name: "Linear P3", white: "D65", toXYZ_M: [[.4865709486482162, .26566769316909306, .1982172852343625], [.2289745640697488, .6917385218365064, .079286914093745], [0, .04511338185890264, 1.043944368900976]], fromXYZ_M: [[2.493496911941425, -.9313836179191239, -.40271078445071684], [-.8294889695615747, 1.7626640603183463, .023624685841943577], [.03584583024378447, -.07617238926804182, .9568845240076872]] }); var K = new y({ id: "srgb-linear", name: "Linear sRGB", white: "D65", toXYZ_M: [[.41239079926595934, .357584339383878, .1804807884018343], [.21263900587151027, .715168678767756, .07219231536073371], [.01933081871559182, .11919477979462598, .9505321522496607]], fromXYZ_M: [[3.2409699419045226, -1.537383177570094, -.4986107602930034], [-.9692436362808796, 1.8759675015077202, .04155505740717559], [.05563007969699366, -.20397695888897652, 1.0569715142428786]], formats: { color: {} } }), U = { aliceblue: [240 / 255, 248 / 255, 1], antiquewhite: [250 / 255, 235 / 255, 215 / 255], aqua: [0, 1, 1], aquamarine: [127 / 255, 1, 212 / 255], azure: [240 / 255, 1, 1], beige: [245 / 255, 245 / 255, 220 / 255], bisque: [1, 228 / 255, 196 / 255], black: [0, 0, 0], blanchedalmond: [1, 235 / 255, 205 / 255], blue: [0, 0, 1], blueviolet: [138 / 255, 43 / 255, 226 / 255], brown: [165 / 255, 42 / 255, 42 / 255], burlywood: [222 / 255, 184 / 255, 135 / 255], cadetblue: [95 / 255, 158 / 255, 160 / 255], chartreuse: [127 / 255, 1, 0], chocolate: [210 / 255, 105 / 255, 30 / 255], coral: [1, 127 / 255, 80 / 255], cornflowerblue: [100 / 255, 149 / 255, 237 / 255], cornsilk: [1, 248 / 255, 220 / 255], crimson: [220 / 255, 20 / 255, 60 / 255], cyan: [0, 1, 1], darkblue: [0, 0, 139 / 255], darkcyan: [0, 139 / 255, 139 / 255], darkgoldenrod: [184 / 255, 134 / 255, 11 / 255], darkgray: [169 / 255, 169 / 255, 169 / 255], darkgreen: [0, 100 / 255, 0], darkgrey: [169 / 255, 169 / 255, 169 / 255], darkkhaki: [189 / 255, 183 / 255, 107 / 255], darkmagenta: [139 / 255, 0, 139 / 255], darkolivegreen: [85 / 255, 107 / 255, 47 / 255], darkorange: [1, 140 / 255, 0], darkorchid: [.6, 50 / 255, .8], darkred: [139 / 255, 0, 0], darksalmon: [233 / 255, 150 / 255, 122 / 255], darkseagreen: [143 / 255, 188 / 255, 143 / 255], darkslateblue: [72 / 255, 61 / 255, 139 / 255], darkslategray: [47 / 255, 79 / 255, 79 / 255], darkslategrey: [47 / 255, 79 / 255, 79 / 255], darkturquoise: [0, 206 / 255, 209 / 255], darkviolet: [148 / 255, 0, 211 / 255], deeppink: [1, 20 / 255, 147 / 255], deepskyblue: [0, 191 / 255, 1], dimgray: [105 / 255, 105 / 255, 105 / 255], dimgrey: [105 / 255, 105 / 255, 105 / 255], dodgerblue: [30 / 255, 144 / 255, 1], firebrick: [178 / 255, 34 / 255, 34 / 255], floralwhite: [1, 250 / 255, 240 / 255], forestgreen: [34 / 255, 139 / 255, 34 / 255], fuchsia: [1, 0, 1], gainsboro: [220 / 255, 220 / 255, 220 / 255], ghostwhite: [248 / 255, 248 / 255, 1], gold: [1, 215 / 255, 0], goldenrod: [218 / 255, 165 / 255, 32 / 255], gray: [128 / 255, 128 / 255, 128 / 255], green: [0, 128 / 255, 0], greenyellow: [173 / 255, 1, 47 / 255], grey: [128 / 255, 128 / 255, 128 / 255], honeydew: [240 / 255, 1, 240 / 255], hotpink: [1, 105 / 255, 180 / 255], indianred: [205 / 255, 92 / 255, 92 / 255], indigo: [75 / 255, 0, 130 / 255], ivory: [1, 1, 240 / 255], khaki: [240 / 255, 230 / 255, 140 / 255], lavender: [230 / 255, 230 / 255, 250 / 255], lavenderblush: [1, 240 / 255, 245 / 255], lawngreen: [124 / 255, 252 / 255, 0], lemonchiffon: [1, 250 / 255, 205 / 255], lightblue: [173 / 255, 216 / 255, 230 / 255], lightcoral: [240 / 255, 128 / 255, 128 / 255], lightcyan: [224 / 255, 1, 1], lightgoldenrodyellow: [250 / 255, 250 / 255, 210 / 255], lightgray: [211 / 255, 211 / 255, 211 / 255], lightgreen: [144 / 255, 238 / 255, 144 / 255], lightgrey: [211 / 255, 211 / 255, 211 / 255], lightpink: [1, 182 / 255, 193 / 255], lightsalmon: [1, 160 / 255, 122 / 255], lightseagreen: [32 / 255, 178 / 255, 170 / 255], lightskyblue: [135 / 255, 206 / 255, 250 / 255], lightslategray: [119 / 255, 136 / 255, .6], lightslategrey: [119 / 255, 136 / 255, .6], lightsteelblue: [176 / 255, 196 / 255, 222 / 255], lightyellow: [1, 1, 224 / 255], lime: [0, 1, 0], limegreen: [50 / 255, 205 / 255, 50 / 255], linen: [250 / 255, 240 / 255, 230 / 255], magenta: [1, 0, 1], maroon: [128 / 255, 0, 0], mediumaquamarine: [.4, 205 / 255, 170 / 255], mediumblue: [0, 0, 205 / 255], mediumorchid: [186 / 255, 85 / 255, 211 / 255], mediumpurple: [147 / 255, 112 / 255, 219 / 255], mediumseagreen: [60 / 255, 179 / 255, 113 / 255], mediumslateblue: [123 / 255, 104 / 255, 238 / 255], mediumspringgreen: [0, 250 / 255, 154 / 255], mediumturquoise: [72 / 255, 209 / 255, .8], mediumvioletred: [199 / 255, 21 / 255, 133 / 255], midnightblue: [25 / 255, 25 / 255, 112 / 255], mintcream: [245 / 255, 1, 250 / 255], mistyrose: [1, 228 / 255, 225 / 255], moccasin: [1, 228 / 255, 181 / 255], navajowhite: [1, 222 / 255, 173 / 255], navy: [0, 0, 128 / 255], oldlace: [253 / 255, 245 / 255, 230 / 255], olive: [128 / 255, 128 / 255, 0], olivedrab: [107 / 255, 142 / 255, 35 / 255], orange: [1, 165 / 255, 0], orangered: [1, 69 / 255, 0], orchid: [218 / 255, 112 / 255, 214 / 255], palegoldenrod: [238 / 255, 232 / 255, 170 / 255], palegreen: [152 / 255, 251 / 255, 152 / 255], paleturquoise: [175 / 255, 238 / 255, 238 / 255], palevioletred: [219 / 255, 112 / 255, 147 / 255], papayawhip: [1, 239 / 255, 213 / 255], peachpuff: [1, 218 / 255, 185 / 255], peru: [205 / 255, 133 / 255, 63 / 255], pink: [1, 192 / 255, 203 / 255], plum: [221 / 255, 160 / 255, 221 / 255], powderblue: [176 / 255, 224 / 255, 230 / 255], purple: [128 / 255, 0, 128 / 255], rebeccapurple: [.4, .2, .6], red: [1, 0, 0], rosybrown: [188 / 255, 143 / 255, 143 / 255], royalblue: [65 / 255, 105 / 255, 225 / 255], saddlebrown: [139 / 255, 69 / 255, 19 / 255], salmon: [250 / 255, 128 / 255, 114 / 255], sandybrown: [244 / 255, 164 / 255, 96 / 255], seagreen: [46 / 255, 139 / 255, 87 / 255], seashell: [1, 245 / 255, 238 / 255], sienna: [160 / 255, 82 / 255, 45 / 255], silver: [192 / 255, 192 / 255, 192 / 255], skyblue: [135 / 255, 206 / 255, 235 / 255], slateblue: [106 / 255, 90 / 255, 205 / 255], slategray: [112 / 255, 128 / 255, 144 / 255], slategrey: [112 / 255, 128 / 255, 144 / 255], snow: [1, 250 / 255, 250 / 255], springgreen: [0, 1, 127 / 255], steelblue: [70 / 255, 130 / 255, 180 / 255], tan: [210 / 255, 180 / 255, 140 / 255], teal: [0, 128 / 255, 128 / 255], thistle: [216 / 255, 191 / 255, 216 / 255], tomato: [1, 99 / 255, 71 / 255], turquoise: [64 / 255, 224 / 255, 208 / 255], violet: [238 / 255, 130 / 255, 238 / 255], wheat: [245 / 255, 222 / 255, 179 / 255], white: [1, 1, 1], whitesmoke: [245 / 255, 245 / 255, 245 / 255], yellow: [1, 1, 0], yellowgreen: [154 / 255, 205 / 255, 50 / 255] }; let Q = Array(3).fill("<percentage> | <number>[0, 255]"), V = Array(3).fill("<number>[0, 255]"); var ee = new y({ id: "srgb", name: "sRGB", base: K, fromBase: e => e.map((e => { let t = e < 0 ? -1 : 1, r = e * t; return r > .0031308 ? t * (1.055 * r ** (1 / 2.4) - .055) : 12.92 * e })), toBase: e => e.map((e => { let t = e < 0 ? -1 : 1, r = e * t; return r < .04045 ? e / 12.92 : t * ((r + .055) / 1.055) ** 2.4 })), formats: { rgb: { coords: Q }, rgb_number: { name: "rgb", commas: !0, coords: V, noAlpha: !0 }, color: {}, rgba: { coords: Q, commas: !0, lastAlpha: !0 }, rgba_number: { name: "rgba", commas: !0, coords: V }, hex: { type: "custom", toGamut: !0, test: e => /^#([a-f0-9]{3,4}){1,2}$/i.test(e), parse(e) { e.length <= 5 && (e = e.replace(/[a-f0-9]/gi, "$&$&")); let t = []; return e.replace(/[a-f0-9]{2}/gi, (e => { t.push(parseInt(e, 16) / 255) })), { spaceId: "srgb", coords: t.slice(0, 3), alpha: t.slice(3)[0] } }, serialize: (e, t, { collapse: r = !0 } = {}) => { t < 1 && e.push(t), e = e.map((e => Math.round(255 * e))); let a = r && e.every((e => e % 17 == 0)), o = e.map((e => a ? (e / 17).toString(16) : e.toString(16).padStart(2, "0"))).join(""); return "#" + o } }, keyword: { type: "custom", test: e => /^[a-z]+$/i.test(e), parse(e) { let t = { spaceId: "srgb", coords: null, alpha: 1 }; if ("transparent" === (e = e.toLowerCase()) ? (t.coords = U.black, t.alpha = 0) : t.coords = U[e], t.coords) return t } } } }), te = new y({ id: "p3", name: "P3", base: J, fromBase: ee.fromBase, toBase: ee.toBase, formats: { color: { id: "display-p3" } } }); if (m.display_space = ee, "undefined" != typeof CSS && CSS.supports) for (let e of [E, W, te]) { let t = e.getMinCoords(), r = Y({ space: e, coords: t, alpha: 1 }); if (CSS.supports("color", r)) { m.display_space = e; break } } function re(e, t, r = "lab") { let a = (r = g.get(r)).from(e), o = r.from(t); return Math.sqrt(a.reduce(((e, t, r) => { let a = o[r]; return isNaN(t) || isNaN(a) ? e : e + (a - t) ** 2 }), 0)) } function ae(e) { return B(e, [w, "y"]) } function oe(e, t) { k(e, [w, "y"], t) } var ne = Object.freeze({ __proto__: null, getLuminance: ae, register: function (e) { Object.defineProperty(e.prototype, "luminance", { get() { return ae(this) }, set(e) { oe(this, e) } }) }, setLuminance: oe }); const se = .022, ie = 1.414; function le(e) { return e >= se ? e : e + (se - e) ** ie } function ce(e) { let t = e < 0 ? -1 : 1, r = Math.abs(e); return t * Math.pow(r, 2.4) } const ue = 24 / 116, he = 24389 / 27; let me = d.D65; var de = new g({ id: "lab-d65", name: "Lab D65", coords: { l: { refRange: [0, 100], name: "L" }, a: { refRange: [-125, 125] }, b: { refRange: [-125, 125] } }, white: me, base: w, fromBase(e) { let t = e.map(((e, t) => e / me[t])).map((e => e > .008856451679035631 ? Math.cbrt(e) : (he * e + 16) / 116)); return [116 * t[1] - 16, 500 * (t[0] - t[1]), 200 * (t[1] - t[2])] }, toBase(e) { let t = []; return t[1] = (e[0] + 16) / 116, t[0] = e[1] / 500 + t[1], t[2] = t[1] - e[2] / 200, [t[0] > ue ? Math.pow(t[0], 3) : (116 * t[0] - 16) / he, e[0] > 8 ? Math.pow((e[0] + 16) / 116, 3) : e[0] / he, t[2] > ue ? Math.pow(t[2], 3) : (116 * t[2] - 16) / he].map(((e, t) => e * me[t])) }, formats: { "lab-d65": { coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"] } } }); const pe = .5 * Math.pow(5, .5) + .5; var fe = Object.freeze({ __proto__: null, contrastAPCA: function (e, t) { let r, a, o, n, s, i; t = _(t), e = _(e), t = X(t, "srgb"), [n, s, i] = t.coords; let l = .2126729 * ce(n) + .7151522 * ce(s) + .072175 * ce(i); e = X(e, "srgb"), [n, s, i] = e.coords; let c = .2126729 * ce(n) + .7151522 * ce(s) + .072175 * ce(i), u = le(l), h = le(c), m = h > u; return Math.abs(h - u) < 5e-4 ? a = 0 : m ? (r = h ** .56 - u ** .57, a = 1.14 * r) : (r = h ** .65 - u ** .62, a = 1.14 * r), o = Math.abs(a) < .1 ? 0 : a > 0 ? a - .027 : a + .027, 100 * o }, contrastDeltaPhi: function (e, t) { e = _(e), t = _(t); let r = B(e, [de, "l"]), a = B(t, [de, "l"]), o = Math.abs(Math.pow(r, pe) - Math.pow(a, pe)), n = Math.pow(o, 1 / pe) * Math.SQRT2 - 40; return n < 7.5 ? 0 : n }, contrastLstar: function (e, t) { e = _(e), t = _(t); let r = B(e, [E, "l"]), a = B(t, [E, "l"]); return Math.abs(r - a) }, contrastMichelson: function (e, t) { e = _(e), t = _(t); let r = Math.max(ae(e), 0), a = Math.max(ae(t), 0); a > r && ([r, a] = [a, r]); let o = r + a; return 0 === o ? 0 : (r - a) / o }, contrastWCAG21: function (e, t) { e = _(e), t = _(t); let r = Math.max(ae(e), 0), a = Math.max(ae(t), 0); return a > r && ([r, a] = [a, r]), (r + .05) / (a + .05) }, contrastWeber: function (e, t) { e = _(e), t = _(t); let r = Math.max(ae(e), 0), a = Math.max(ae(t), 0); return a > r && ([r, a] = [a, r]), 0 === a ? 5e4 : (r - a) / a } }); function ge(e) { let [t, r, a] = v(e, w), o = t + 15 * r + 3 * a; return [4 * t / o, 9 * r / o] } function be(e) { let [t, r, a] = v(e, w), o = t + r + a; return [t / o, r / o] } var Me = Object.freeze({ __proto__: null, register: function (e) { Object.defineProperty(e.prototype, "uv", { get() { return ge(this) } }), Object.defineProperty(e.prototype, "xy", { get() { return be(this) } }) }, uv: ge, xy: be }); const we = Math.PI / 180; var ye = new g({ id: "xyz-abs-d65", name: "Absolute XYZ D65", coords: { x: { refRange: [0, 9504.7], name: "Xa" }, y: { refRange: [0, 1e4], name: "Ya" }, z: { refRange: [0, 10888.3], name: "Za" } }, base: w, fromBase: e => e.map((e => Math.max(203 * e, 0))), toBase: e => e.map((e => Math.max(e / 203, 0))) }); const Ce = 1.15, _e = .66, ve = 2610 / 16384, Be = .8359375, Re = 2413 / 128, ke = 18.6875, xe = 32 / (1.7 * 2523), Ae = -.56, Ne = 16295499532821565e-27, ze = [[.41478972, .579999, .014648], [-.20151, 1.120649, .0531008], [-.0166008, .2648, .6684799]], Ee = [[1.9242264357876067, -1.0047923125953657, .037651404030618], [.35031676209499907, .7264811939316552, -.06538442294808501], [-.09098281098284752, -.3127282905230739, 1.5227665613052603]], je = [[.5, .5, 0], [3.524, -4.066708, .542708], [.199076, 1.096799, -1.295875]], Pe = [[1, .1386050432715393, .05804731615611886], [.9999999999999999, -.1386050432715393, -.05804731615611886], [.9999999999999998, -.09601924202631895, -.8118918960560388]]; var Le = new g({ id: "jzazbz", name: "Jzazbz", coords: { jz: { refRange: [0, 1], name: "Jz" }, az: { refRange: [-.5, .5] }, bz: { refRange: [-.5, .5] } }, base: ye, fromBase(t) { let [r, a, o] = t, n = e(ze, [Ce * r - (Ce - 1) * o, _e * a - (_e - 1) * r, o]).map((function (e) { return ((Be + Re * (e / 1e4) ** ve) / (1 + ke * (e / 1e4) ** ve)) ** 134.03437499999998 })), [s, i, l] = e(je, n); return [(1 + Ae) * s / (1 + Ae * s) - Ne, i, l] }, toBase(t) { let [r, a, o] = t, n = e(Pe, [(r + Ne) / (1 + Ae - Ae * (r + Ne)), a, o]).map((function (e) { return 1e4 * ((Be - e ** xe) / (ke * e ** xe - Re)) ** 6.277394636015326 })), [s, i, l] = e(Ee, n), c = (s + (Ce - 1) * l) / Ce; return [c, (i + (_e - 1) * c) / _e, l] }, formats: { color: {} } }), Oe = new g({ id: "jzczhz", name: "JzCzHz", coords: { jz: { refRange: [0, 1], name: "Jz" }, cz: { refRange: [0, 1], name: "Chroma" }, hz: { refRange: [0, 360], type: "angle", name: "Hue" } }, base: Le, fromBase(e) { let t, [r, a, o] = e; const n = 2e-4; return t = Math.abs(a) < n && Math.abs(o) < n ? NaN : 180 * Math.atan2(o, a) / Math.PI, [r, Math.sqrt(a ** 2 + o ** 2), j(t)] }, toBase: e => [e[0], e[1] * Math.cos(e[2] * Math.PI / 180), e[1] * Math.sin(e[2] * Math.PI / 180)], formats: { color: {} } }); const Se = .8359375, $e = 2413 / 128, De = 18.6875, Ie = 2610 / 16384, qe = 2523 / 32, Ge = 16384 / 2610, Te = 32 / 2523, Xe = [[.3592, .6976, -.0358], [-.1922, 1.1004, .0755], [.007, .0749, .8434]], Ye = [[.5, .5, 0], [6610 / 4096, -13613 / 4096, 7003 / 4096], [17933 / 4096, -17390 / 4096, -543 / 4096]], Ze = [[.9999888965628402, .008605050147287059, .11103437159861648], [1.00001110343716, -.008605050147287059, -.11103437159861648], [1.0000320633910054, .56004913547279, -.3206339100541203]], Fe = [[2.0701800566956137, -1.326456876103021, .20661600684785517], [.3649882500326575, .6804673628522352, -.04542175307585323], [-.04959554223893211, -.04942116118675749, 1.1879959417328034]]; var He = new g({ id: "ictcp", name: "ICTCP", coords: { i: { refRange: [0, 1], name: "I" }, ct: { refRange: [-.5, .5], name: "CT" }, cp: { refRange: [-.5, .5], name: "CP" } }, base: ye, fromBase: t => function (t) { let r = t.map((function (e) { return ((Se + $e * (e / 1e4) ** Ie) / (1 + De * (e / 1e4) ** Ie)) ** qe })); return e(Ye, r) }(e(Xe, t)), toBase(t) { let r = function (t) { let r = e(Ze, t), a = r.map((function (e) { return 1e4 * (Math.max(e ** Te - Se, 0) / ($e - De * e ** Te)) ** Ge })); return a }(t); return e(Fe, r) }, formats: { color: {} } }); const We = [[.8190224432164319, .3619062562801221, -.12887378261216414], [.0329836671980271, .9292868468965546, .03614466816999844], [.048177199566046255, .26423952494422764, .6335478258136937]], Je = [[1.2268798733741557, -.5578149965554813, .28139105017721583], [-.04057576262431372, 1.1122868293970594, -.07171106666151701], [-.07637294974672142, -.4214933239627914, 1.5869240244272418]], Ke = [[.2104542553, .793617785, -.0040720468], [1.9779984951, -2.428592205, .4505937099], [.0259040371, .7827717662, -.808675766]], Ue = [[.9999999984505198, .39633779217376786, .2158037580607588], [1.0000000088817609, -.10556134232365635, -.06385417477170591], [1.0000000546724108, -.08948418209496575, -1.2914855378640917]]; var Qe = new g({ id: "oklab", name: "Oklab", coords: { l: { refRange: [0, 1], name: "L" }, a: { refRange: [-.4, .4] }, b: { refRange: [-.4, .4] } }, white: "D65", base: w, fromBase(t) { let r = e(We, t).map((e => Math.cbrt(e))); return e(Ke, r) }, toBase(t) { let r = e(Ue, t).map((e => e ** 3)); return e(Je, r) }, formats: { oklab: { coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"] } } }); var Ve = { deltaE76: function (e, t) { return re(e, t, "lab") }, deltaECMC: function (e, t, { l: r = 2, c: a = 1 } = {}) { let [o, n, s] = E.from(e), [, i, l] = P.from(E, [o, n, s]), [c, u, h] = E.from(t), m = P.from(E, [c, u, h])[1]; i < 0 && (i = 0), m < 0 && (m = 0); let d = o - c, p = i - m, f = (n - u) ** 2 + (s - h) ** 2 - p ** 2, g = .511; o >= 16 && (g = .040975 * o / (1 + .01765 * o)); let b, M = .0638 * i / (1 + .0131 * i) + .638; Number.isNaN(l) && (l = 0), b = l >= 164 && l <= 345 ? .56 + Math.abs(.2 * Math.cos((l + 168) * we)) : .36 + Math.abs(.4 * Math.cos((l + 35) * we)); let w = Math.pow(i, 4), y = Math.sqrt(w / (w + 1900)), C = (d / (r * g)) ** 2; return C += (p / (a * M)) ** 2, C += f / (M * (y * b + 1 - y)) ** 2, Math.sqrt(C) }, deltaE2000: D, deltaEJz: function (e, t) { let [r, a, o] = Oe.from(e), [n, s, i] = Oe.from(t), l = r - n, c = a - s; Number.isNaN(o) && Number.isNaN(i) ? (o = 0, i = 0) : Number.isNaN(o) ? o = i : Number.isNaN(i) && (i = o); let u = o - i, h = 2 * Math.sqrt(a * s) * Math.sin(u / 2 * (Math.PI / 180)); return Math.sqrt(l ** 2 + c ** 2 + h ** 2) }, deltaEITP: function (e, t) { let [r, a, o] = He.from(e), [n, s, i] = He.from(t); return 720 * Math.sqrt((r - n) ** 2 + .25 * (a - s) ** 2 + (o - i) ** 2) }, deltaEOK: function (e, t) { let [r, a, o] = Qe.from(e), [n, s, i] = Qe.from(t), l = r - n, c = a - s, u = o - i; return Math.sqrt(l ** 2 + c ** 2 + u ** 2) } }; function et(e, r, a = {}) { t(a) && (a = { method: a }); let { method: o = m.deltaE, ...n } = a; e = _(e), r = _(r); for (let t in Ve) if ("deltae" + o.toLowerCase() === t.toLowerCase()) return Ve[t](e, r, n); throw new TypeError(`Unknown deltaE method: ${o}`) } var tt = Object.freeze({ __proto__: null, darken: function (e, t = .25) { return k(e, [g.get("oklch", "lch"), "l"], (e => e * (1 - t))) }, lighten: function (e, t = .25) { return k(e, [g.get("oklch", "lch"), "l"], (e => e * (1 + t))) } }); function rt(e, t, a = .5, o = {}) { [e, t] = [_(e), _(t)], "object" === r(a) && ([a, o] = [.5, a]); let { space: n, outputSpace: s, premultiplied: i } = o; return ot(e, t, { space: n, outputSpace: s, premultiplied: i })(a) } function at(e, t, r = {}) { let a; nt(e) && ([a, r] = [e, t], [e, t] = a.rangeArgs.colors); let { maxDeltaE: o, deltaEMethod: n, steps: s = 2, maxSteps: i = 1e3, ...l } = r; a || ([e, t] = [_(e), _(t)], a = ot(e, t, l)); let c = et(e, t), u = o > 0 ? Math.max(s, Math.ceil(c / o) + 1) : s, h = []; if (void 0 !== i && (u = Math.min(u, i)), 1 === u) h = [{ p: .5, color: a(.5) }]; else { let e = 1 / (u - 1); h = Array.from({ length: u }, ((t, r) => { let o = r * e; return { p: o, color: a(o) } })) } if (o > 0) { let e = h.reduce(((e, t, r) => { if (0 === r) return 0; let a = et(t.color, h[r - 1].color, n); return Math.max(e, a) }), 0); for (; e > o;) { e = 0; for (let t = 1; t < h.length && h.length < i; t++) { let r = h[t - 1], o = h[t], n = (o.p + r.p) / 2, s = a(n); e = Math.max(e, et(s, r.color), et(s, o.color)), h.splice(t, 0, { p: n, color: a(n) }), t++ } } } return h = h.map((e => e.color)), h } function ot(e, t, r = {}) { if (nt(e)) { let [r, a] = [e, t]; return ot(...r.rangeArgs.colors, { ...r.rangeArgs.options, ...a }) } let { space: a, outputSpace: o, progression: n, premultiplied: i } = r; e = _(e), t = _(t), e = G(e), t = G(t); let l = { colors: [e, t], options: r }; if (a = a ? g.get(a) : g.registry[m.interpolationSpace] || e.space, o = o ? g.get(o) : a, e = X(e, a), t = X(t, a), e = T(e), t = T(t), a.coords.h && "angle" === a.coords.h.type) { let o = r.hue = r.hue || "shorter", n = [a, "h"], [s, i] = [B(e, n), B(t, n)];[s, i] = function (e, t) { if ("raw" === e) return t; let [r, a] = t.map(j), o = a - r; return "increasing" === e ? o < 0 && (a += 360) : "decreasing" === e ? o > 0 && (r += 360) : "longer" === e ? -180 < o && o < 180 && (o > 0 ? r += 360 : a += 360) : "shorter" === e && (o > 180 ? r += 360 : o < -180 && (a += 360)), [r, a] }(o, [s, i]), k(e, n, s), k(t, n, i) } return i && (e.coords = e.coords.map((t => t * e.alpha)), t.coords = t.coords.map((e => e * t.alpha))), Object.assign((r => { r = n ? n(r) : r; let l = e.coords.map(((e, a) => s(e, t.coords[a], r))), c = s(e.alpha, t.alpha, r), u = { space: a, coords: l, alpha: c }; return i && (u.coords = u.coords.map((e => e / c))), o !== a && (u = X(u, o)), u }), { rangeArgs: l }) } function nt(e) { return "function" === r(e) && !!e.rangeArgs } m.interpolationSpace = "lab"; var st = Object.freeze({ __proto__: null, isRange: nt, mix: rt, range: ot, register: function (e) { e.defineFunction("mix", rt, { returns: "color" }), e.defineFunction("range", ot, { returns: "function<color>" }), e.defineFunction("steps", at, { returns: "array<color>" }) }, steps: at }), it = new g({ id: "hsl", name: "HSL", coords: { h: { refRange: [0, 360], type: "angle", name: "Hue" }, s: { range: [0, 100], name: "Saturation" }, l: { range: [0, 100], name: "Lightness" } }, base: ee, fromBase: e => { let t = Math.max(...e), r = Math.min(...e), [a, o, n] = e, [s, i, l] = [NaN, 0, (r + t) / 2], c = t - r; if (0 !== c) { switch (i = 0 === l || 1 === l ? 0 : (t - l) / Math.min(l, 1 - l), t) { case a: s = (o - n) / c + (o < n ? 6 : 0); break; case o: s = (n - a) / c + 2; break; case n: s = (a - o) / c + 4 }s *= 60 } return [s, 100 * i, 100 * l] }, toBase: e => { let [t, r, a] = e; function o(e) { let o = (e + t / 30) % 12, n = r * Math.min(a, 1 - a); return a - n * Math.max(-1, Math.min(o - 3, 9 - o, 1)) } return t %= 360, t < 0 && (t += 360), r /= 100, a /= 100, [o(0), o(8), o(4)] }, formats: { hsl: { toGamut: !0, coords: ["<number> | <angle>", "<percentage>", "<percentage>"] }, hsla: { coords: ["<number> | <angle>", "<percentage>", "<percentage>"], commas: !0, lastAlpha: !0 } } }), lt = new g({ id: "hsv", name: "HSV", coords: { h: { refRange: [0, 360], type: "angle", name: "Hue" }, s: { range: [0, 100], name: "Saturation" }, v: { range: [0, 100], name: "Value" } }, base: it, fromBase(e) { let [t, r, a] = e; r /= 100, a /= 100; let o = a + r * Math.min(a, 1 - a); return [t, 0 === o ? 0 : 200 * (1 - a / o), 100 * o] }, toBase(e) { let [t, r, a] = e; r /= 100, a /= 100; let o = a * (1 - r / 2); return [t, 0 === o || 1 === o ? 0 : (a - o) / Math.min(o, 1 - o) * 100, 100 * o] }, formats: { color: { toGamut: !0 } } }), ct = new g({ id: "hwb", name: "HWB", coords: { h: { refRange: [0, 360], type: "angle", name: "Hue" }, w: { range: [0, 100], name: "Whiteness" }, b: { range: [0, 100], name: "Blackness" } }, base: lt, fromBase(e) { let [t, r, a] = e; return [t, a * (100 - r) / 100, 100 - a] }, toBase(e) { let [t, r, a] = e; r /= 100, a /= 100; let o = r + a; if (o >= 1) { return [t, 0, 100 * (r / o)] } let n = 1 - a; return [t, 100 * (0 === n ? 0 : 1 - r / n), 100 * n] }, formats: { hwb: { toGamut: !0, coords: ["<number> | <angle>", "<percentage>", "<percentage>"] } } }); var ut = new y({ id: "a98rgb-linear", name: "Linear Adobe® 98 RGB compatible", white: "D65", toXYZ_M: [[.5766690429101305, .1855582379065463, .1882286462349947], [.29734497525053605, .6273635662554661, .07529145849399788], [.02703136138641234, .07068885253582723, .9913375368376388]], fromXYZ_M: [[2.0415879038107465, -.5650069742788596, -.34473135077832956], [-.9692436362808795, 1.8759675015077202, .04155505740717557], [.013444280632031142, -.11836239223101838, 1.0151749943912054]] }), ht = new y({ id: "a98rgb", name: "Adobe® 98 RGB compatible", base: ut, toBase: e => e.map((e => Math.pow(Math.abs(e), 563 / 256) * Math.sign(e))), fromBase: e => e.map((e => Math.pow(Math.abs(e), 256 / 563) * Math.sign(e))), formats: { color: { id: "a98-rgb" } } }); var mt = new y({ id: "prophoto-linear", name: "Linear ProPhoto", white: "D50", base: x, toXYZ_M: [[.7977604896723027, .13518583717574031, .0313493495815248], [.2880711282292934, .7118432178101014, 8565396060525902e-20], [0, 0, .8251046025104601]], fromXYZ_M: [[1.3457989731028281, -.25558010007997534, -.05110628506753401], [-.5446224939028347, 1.5082327413132781, .02053603239147973], [0, 0, 1.2119675456389454]] }); var dt = new y({ id: "prophoto", name: "ProPhoto", base: mt, toBase: e => e.map((e => e < .03125 ? e / 16 : e ** 1.8)), fromBase: e => e.map((e => e >= .001953125 ? e ** (1 / 1.8) : 16 * e)), formats: { color: { id: "prophoto-rgb" } } }), pt = new g({ id: "oklch", name: "Oklch", coords: { l: { refRange: [0, 1], name: "Lightness" }, c: { refRange: [0, .4], name: "Chroma" }, h: { refRange: [0, 360], type: "angle", name: "Hue" } }, white: "D65", base: Qe, fromBase(e) { let t, [r, a, o] = e; const n = 2e-4; return t = Math.abs(a) < n && Math.abs(o) < n ? NaN : 180 * Math.atan2(o, a) / Math.PI, [r, Math.sqrt(a ** 2 + o ** 2), j(t)] }, toBase(e) { let t, r, [a, o, n] = e; return isNaN(n) ? (t = 0, r = 0) : (t = o * Math.cos(n * Math.PI / 180), r = o * Math.sin(n * Math.PI / 180)), [a, t, r] }, formats: { oklch: { coords: ["<number> | <percentage>", "<number> | <percentage>[0,1]", "<number> | <angle>"] } } }); const ft = 2610 / 16384, gt = 32 / 2523, bt = .8359375, Mt = 2413 / 128, wt = 18.6875; var yt = new y({ id: "rec2100pq", name: "REC.2100-PQ", base: Z, toBase: e => e.map((function (e) { return 1e4 * (Math.max(e ** gt - bt, 0) / (Mt - wt * e ** gt)) ** 6.277394636015326 / 203 })), fromBase: e => e.map((function (e) { let t = Math.max(203 * e / 1e4, 0); return ((bt + Mt * t ** ft) / (1 + wt * t ** ft)) ** 78.84375 })), formats: { color: { id: "rec2100-pq" } } }); const Ct = .17883277, _t = .28466892, vt = .55991073, Bt = 3.7743; var Rt = new y({ id: "rec2100hlg", cssid: "rec2100-hlg", name: "REC.2100-HLG", referred: "scene", base: Z, toBase: e => e.map((function (e) { return e <= .5 ? e ** 2 / 3 * Bt : (Math.exp((e - vt) / Ct) + _t) / 12 * Bt })), fromBase: e => e.map((function (e) { return (e /= Bt) <= 1 / 12 ? Math.sqrt(3 * e) : Ct * Math.log(12 * e - _t) + vt })), formats: { color: { id: "rec2100-hlg" } } }); const kt = {}; function xt({ id: e, toCone_M: t, fromCone_M: r }) { kt[e] = arguments[0] } function At(t, r, a = "Bradford") { let o = kt[a], [n, s, i] = e(o.toCone_M, t), [l, c, u] = e(o.toCone_M, r), h = e([[l / n, 0, 0], [0, c / s, 0], [0, 0, u / i]], o.toCone_M); return e(o.fromCone_M, h) } h.add("chromatic-adaptation-start", (e => { e.options.method && (e.M = At(e.W1, e.W2, e.options.method)) })), h.add("chromatic-adaptation-end", (e => { e.M || (e.M = At(e.W1, e.W2, e.options.method)) })), xt({ id: "von Kries", toCone_M: [[.40024, .7076, -.08081], [-.2263, 1.16532, .0457], [0, 0, .91822]], fromCone_M: [[1.8599364, -1.1293816, .2198974], [.3611914, .6388125, -64e-7], [0, 0, 1.0890636]] }), xt({ id: "Bradford", toCone_M: [[.8951, .2664, -.1614], [-.7502, 1.7135, .0367], [.0389, -.0685, 1.0296]], fromCone_M: [[.9869929, -.1470543, .1599627], [.4323053, .5183603, .0492912], [-.0085287, .0400428, .9684867]] }), xt({ id: "CAT02", toCone_M: [[.7328, .4296, -.1624], [-.7036, 1.6975, .0061], [.003, .0136, .9834]], fromCone_M: [[1.0961238, -.278869, .1827452], [.454369, .4735332, .0720978], [-.0096276, -.005698, 1.0153256]] }), xt({ id: "CAT16", toCone_M: [[.401288, .650173, -.051461], [-.250268, 1.204414, .045854], [-.002079, .048952, .953127]], fromCone_M: [[1.862067855087233, -1.011254630531685, .1491867754444518], [.3875265432361372, .6214474419314753, -.008973985167612518], [-.01584149884933386, -.03412293802851557, 1.04996443687785]] }), Object.assign(d, { A: [1.0985, 1, .35585], C: [.98074, 1, 1.18232], D55: [.95682, 1, .92149], D75: [.94972, 1, 1.22638], E: [1, 1, 1], F2: [.99186, 1, .67393], F7: [.95041, 1, 1.08747], F11: [1.00962, 1, .6435] }), d.ACES = [.32168 / .33767, 1, .34065 / .33767]; var Nt = new y({ id: "acescg", name: "ACEScg", coords: { r: { range: [0, 65504], name: "Red" }, g: { range: [0, 65504], name: "Green" }, b: { range: [0, 65504], name: "Blue" } }, referred: "scene", white: d.ACES, toXYZ_M: [[.6624541811085053, .13400420645643313, .1561876870049078], [.27222871678091454, .6740817658111484, .05368951740793705], [-.005574649490394108, .004060733528982826, 1.0103391003129971]], fromXYZ_M: [[1.6410233796943257, -.32480329418479, -.23642469523761225], [-.6636628587229829, 1.6153315916573379, .016756347685530137], [.011721894328375376, -.008284441996237409, .9883948585390215]], formats: { color: {} } }); const zt = 2 ** -16, Et = -.35828683, jt = (Math.log2(65504) + 9.72) / 17.52; var Pt = new y({ id: "acescc", name: "ACEScc", coords: { r: { range: [Et, jt], name: "Red" }, g: { range: [Et, jt], name: "Green" }, b: { range: [Et, jt], name: "Blue" } }, referred: "scene", base: Nt, toBase: e => e.map((function (e) { return e <= -.3013698630136986 ? 2 * (2 ** (17.52 * e - 9.72) - zt) : e < jt ? 2 ** (17.52 * e - 9.72) : 65504 })), fromBase: e => e.map((function (e) { return e <= 0 ? (Math.log2(zt) + 9.72) / 17.52 : e < zt ? (Math.log2(zt + .5 * e) + 9.72) / 17.52 : (Math.log2(e) + 9.72) / 17.52 })), formats: { color: {} } }), Lt = Object.freeze({ __proto__: null, A98RGB: ht, A98RGB_Linear: ut, ACEScc: Pt, ACEScg: Nt, HSL: it, HSV: lt, HWB: ct, ICTCP: He, JzCzHz: Oe, Jzazbz: Le, LCH: P, Lab: E, Lab_D65: de, OKLCH: pt, OKLab: Qe, P3: te, P3_Linear: J, ProPhoto: dt, ProPhoto_Linear: mt, REC_2020: W, REC_2020_Linear: Z, REC_2100_HLG: Rt, REC_2100_PQ: yt, XYZ_ABS_D65: ye, XYZ_D50: x, XYZ_D65: w, sRGB: ee, sRGB_Linear: K }); class Ot { constructor(...e) { let t, r, a, o; 1 === e.length && (t = _(e[0])), t ? (r = t.space || t.spaceId, a = t.coords, o = t.alpha) : [r, a, o] = e, Object.defineProperty(this, "space", { value: g.get(r), writable: !1, enumerable: !0, configurable: !0 }), this.coords = a ? a.slice() : [0, 0, 0], this.alpha = o < 1 ? o : 1; for (let e = 0; e < this.coords.length; e++)"NaN" === this.coords[e] && (this.coords[e] = NaN); for (let e in this.space.coords) Object.defineProperty(this, e, { get: () => this.get(e), set: t => this.set(e, t) }) } get spaceId() { return this.space.id } clone() { return new Ot(this.space, this.coords, this.alpha) } toJSON() { return { spaceId: this.spaceId, coords: this.coords, alpha: this.alpha } } display(...e) { let t = function (e, { space: t = m.display_space, ...r } = {}) { let a = Y(e, r); if ("undefined" == typeof CSS || CSS.supports("color", a) || !m.display_space) a = new String(a), a.color = e; else { let o = X(e, t); a = new String(Y(o, r)), a.color = o } return a }(this, ...e); return t.color = new Ot(t.color), t } static get(e, ...t) { return e instanceof Ot ? e : new Ot(e, ...t) } static defineFunction(e, t, r = t) { let { instance: a = !0, returns: o } = r, n = function (...e) { let r = t(...e); if ("color" === o) r = Ot.get(r); else if ("function<color>" === o) { let e = r; r = function (...t) { let r = e(...t); return Ot.get(r) }, Object.assign(r, e) } else "array<color>" === o && (r = r.map((e => Ot.get(e)))); return r }; e in Ot || (Ot[e] = n), a && (Ot.prototype[e] = function (...e) { return n(this, ...e) }) } static defineFunctions(e) { for (let t in e) Ot.defineFunction(t, e[t], e[t]) } static extend(e) { if (e.register) e.register(Ot); else for (let t in e) Ot.defineFunction(t, e[t]) } } Ot.defineFunctions({ get: B, getAll: v, set: k, setAll: R, to: X, equals: function (e, t) { return e = _(e), t = _(t), e.space === t.space && e.alpha === t.alpha && e.coords.every(((e, r) => e === t.coords[r])) }, inGamut: q, toGamut: T, distance: re, toString: Y }), Object.assign(Ot, { util: u, hooks: h, WHITES: d, Space: g, spaces: g.registry, parse: C, defaults: m }); for (let e of Object.keys(Lt)) g.register(Lt[e]); for (let e in g.registry) St(e, g.registry[e]); function St(e, t) { Object.keys(t.coords), Object.values(t.coords).map((e => e.name)); let r = e.replace(/-/g, "_"); Object.defineProperty(Ot.prototype, r, { get() { let r = this.getAll(e); return "undefined" == typeof Proxy ? r : new Proxy(r, { has: (e, r) => { try { return g.resolveCoord([t, r]), !0 } catch (e) { } return Reflect.has(e, r) }, get: (e, r, a) => { if (r && "symbol" != typeof r && !(r in e)) { let { index: a } = g.resolveCoord([t, r]); if (a >= 0) return e[a] } return Reflect.get(e, r, a) }, set: (r, a, o, n) => { if (a && "symbol" != typeof a && !(a in r) || a >= 0) { let { index: n } = g.resolveCoord([t, a]); if (n >= 0) return r[n] = o, this.setAll(e, r), !0 } return Reflect.set(r, a, o, n) } }) }, set(t) { this.setAll(e, t) }, configurable: !0, enumerable: !0 }) } return h.add("colorspace-init-end", (e => { St(e.id, e), e.aliases?.forEach((t => { St(t, e) })) })), Ot.extend(Ve), Ot.extend({ deltaE: et }), Object.assign(Ot, { deltaEMethods: Ve }), Ot.extend(tt), Ot.extend({ contrast: function (e, r, a = {}) { t(a) && (a = { algorithm: a }); let { algorithm: o, ...n } = a; if (!o) { let e = Object.keys(fe).map((e => e.replace(/^contrast/, ""))).join(", "); throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${e}`) } e = _(e), r = _(r); for (let t in fe) if ("contrast" + o.toLowerCase() === t.toLowerCase()) return fe[t](e, r, n); throw new TypeError(`Unknown contrast algorithm: ${o}`) } }), Ot.extend(Me), Ot.extend(ne), Ot.extend(st), Ot.extend(fe), Ot }();
//# sourceMappingURL=color.global.min.js.map